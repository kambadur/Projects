/*
******************************************************    Generated by an AI language model   ******************************************************

*********   Module description    ************
This is a Verilog module that models a Permanent Magnet Synchronous Motor (PMSM). It takes three-phase voltage inputs and outputs the motor phase currents, electromagnetic torque, 
motor speed, and rotor position.

The module has a clock input, which is used to drive the motor model. The input voltage is represented by a 3-bit vector V_phase. 
The module also has several parameters that define the motor's characteristics, such as the number of poles, rotor resistance, rotor inductance, moment of inertia, and viscous friction.

The module uses several variables to perform the necessary calculations. These variables include I_alpha, I_beta, theta, omega, alpha, beta, V_alpha, V_beta, V_d, V_q, I_d, and I_q.

The Clarke Transform block converts the three-phase input voltage into two orthogonal components, alpha and beta. 
The Park Transform block then rotates the alpha and beta components by the rotor position angle, theta, to produce the d and q components of the voltage and current.

The Motor Model block uses the inputs to calculate the electromagnetic torque generated by the motor, based on the current and voltage. 
The torque calculation is based on the motor's magnetic field strength, the number of poles, and the rotor position. 
The motor's speed and position are also calculated using the motor model equations.

The module has three output signals representing the three motor phase currents, I_a, I_b, and I_c, which are represented by 16-bit vectors. 
It also outputs the calculated electromagnetic torque, speed, and position of the motor.

Overall, this Verilog module models the behavior of a Permanent Magnet Synchronous Motor and allows simulation and synthesis of the motor's behavior in a digital design.
*/

/*
*********   Rotor position calculation    ************

Sure! In the given Verilog RTL code for the Permanent Magnet Synchronous Motor (PMSM), the rotor position is calculated using the Park transformation.

The Park transformation is used to transform the stator current components in the stationary reference frame (alpha-beta frame) to the current components 
in the synchronous reference frame (d-q frame) with respect to the rotor angle. In this transformation, the stator current components (I_alpha, I_beta) are transformed 
to the current components (I_d, I_q) in the synchronous reference frame with respect to the rotor angle (theta).

The Park transformation is given by:

I_d = I_alpha * cos(theta) + I_beta * sin(theta)
I_q = -I_alpha * sin(theta) + I_beta * cos(theta)

In the given Verilog RTL code, the rotor position (theta) is obtained from the rotor speed. The rotor speed is obtained from the electromagnetic torque generated by the motor 
using the equation:

torque = (3/2) * poles * N * (I_q * V_d - I_d * V_q)
speed = speed + ((torque - B * speed) / (J * clks_per_rev)) // clks_per_rev is the number of clock cycles per revolution of the rotor

Here, the rotor speed is updated using the equation of motion for the rotor, which includes the electromagnetic torque (torque) generated by the motor 
and the damping force (B * speed) acting on the rotor. The rotor speed is then used to update the rotor position (theta) using the equation:

theta = theta + (2 * pi * speed) / clks_per_rev

In this equation, the rotor position is updated based on the rotor speed and the number of clock cycles per revolution of the rotor (clks_per_rev). 
Therefore, the rotor position is calculated as a function of the rotor speed and the number of clock cycles per revolution of the rotor.
*/

/*
******************    Interface to Inverter terminals     **************************
The V_phase input of the PMSM module is intended to be connected to the output of a three-phase inverter. 
The inverter converts a DC voltage to a three-phase AC voltage, which can be used to drive the PMSM.

In the PMSM module, the Clarke Transform block transforms the three-phase input voltage V_phase into two-phase components alpha and beta. 
These components are then transformed into the d and q components V_d and V_q using the Park Transform block, which are then used to control the motor using the Motor Model block.

*/

module PMSM(
  input clk,                      // System clock input
  input [2:0] V_phase,            // Input voltages for each phase
  output reg [15:0] I_a,          // Output current for phase a
  output reg [15:0] I_b,          // Output current for phase b
  output reg [15:0] I_c,          // Output current for phase c (calculated by current conservation)
  output reg [15:0] torque,       // Output electromagnetic torque
  output reg [15:0] speed,        // Output motor speed (in radians per second)
  output reg [15:0] position      // Output rotor position (in radians)
);

// Parameters
parameter integer N = 60; // Number of poles
parameter integer R = 1;  // Rotor resistance (in ohms)
parameter integer L = 1;  // Rotor inductance (in henries)
parameter integer J = 1;  // Moment of inertia (in kg.m^2)
parameter integer B = 1;  // Viscous friction (in N.m.s/rad)

// Variables
reg [15:0] I_alpha;             // Current component along d-axis
reg [15:0] I_beta;              // Current component along q-axis
reg [15:0] theta;               // Rotor position (in radians)
reg [15:0] omega;               // Rotor speed (in radians per second)
reg [15:0] alpha;               // Component of input voltage along a-axis
reg [15:0] beta;                // Component of input voltage along b-axis
reg [15:0] V_alpha;             // Component of input voltage along d-axis
reg [15:0] V_beta;              // Component of input voltage along q-axis
reg [15:0] V_d;                 // Component of input voltage along d-axis
reg [15:0] V_q;                 // Component of input voltage along q-axis
reg [15:0] I_d;                 // Current component along d-axis
reg [15:0] I_q;                 // Current component along q-axis

// Clarke Transform
always @ (V_phase) begin
  alpha <= V_phase[0];           // Component of input voltage along a-axis
  beta <= (V_phase[1] - V_phase[2]) / 2;  // Component of input voltage along b-axis
end

// Park Transform
always @ (theta) begin
  V_alpha <= alpha * $cos(theta) + beta * $sin(theta); // Component of input voltage along d-axis
  V_beta <= -alpha * $sin(theta) + beta * $cos(theta); // Component of input voltage along q-axis
  I_alpha <= I_a * $cos(theta) + I_b * $sin(theta);    // Current component along d-axis
  I_beta <= -I_a * $sin(theta) + I_b * $cos(theta);    // Current component along q-axis
end

// Inverse Park Transform
always @ (theta) begin
  I_d <= I_alpha * $cos(theta) - I_beta * $sin(theta); // Current component along d-axis
  I_q <= I_alpha * $sin(theta) + I_beta * $cos(theta); // Current component along q-axis
end

// Inverse Clarke Transform
always @ (V_alpha, V_beta) begin
  V_d <= V_alpha * $cos(theta) + V_beta * $sin(theta);  // Component of input voltage along d-axis
  V_q <= -V_alpha * $sin(theta) + V_beta * $cos(theta); // Component of input voltage along q-axis
end

// Current Conservation
always @ (I_d, I_q) begin
  I_c <= -I_a - I_b;   // Current component along c-axis (calculated by current conservation)
end

// Electromagnetic Torque
always @ (I_d, I_q) begin
  torque <= (3/2) * N * (L*I_q*I_d - R*I_q^2); // Electromagnetic torque (in N.m)
end

// Rotor Dynamics
always @ (I_d, I_q, omega) begin
  omega <= omega + ((1/J) * (torque - B*omega)); // Rotor speed (in radians per second)
end

// Position Calculation
always @ (omega) begin
  //theta <= theta + (omega * (1/clks_per_rev)); // Rotor position (in radians)
  theta <= theta + omega;
  position <= theta;                          // Rotor position (in radians)
end

// End of module
endmodule
